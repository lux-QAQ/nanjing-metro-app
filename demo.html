<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å—äº¬åœ°é“æ™ºæ…§å‡ºè¡Œç³»ç»Ÿ</title>
    <style>
        :root {
            --primary: #007AFF;
            --bg: #F5F5F7;
            --card-bg: rgba(255, 255, 255, 0.9);
            --text-main: #1D1D1F;
            --text-sub: #86868B;
            --shadow: 0 4px 24px rgba(0, 0, 0, 0.08);
            --radius: 16px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        /* Sidebar Styling */
        .sidebar {
            width: 360px;
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            padding: 24px;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow);
            z-index: 10;
            border-right: 1px solid rgba(0, 0, 0, 0.1);
        }

        .brand {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 24px;
            color: #b91b2f;
            /* Nanjing Metro Red */
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-sub);
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        select,
        button {
            width: 100%;
            padding: 12px;
            border-radius: 10px;
            border: 1px solid #d2d2d7;
            background: #fff;
            font-size: 15px;
            outline: none;
            transition: all 0.2s;
        }

        select:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
        }

        .strategy-group {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
        }

        .strategy-btn {
            flex: 1;
            padding: 8px;
            font-size: 12px;
            background: #eee;
            border: none;
            cursor: pointer;
            color: var(--text-sub);
        }

        .strategy-btn.active {
            background: var(--primary);
            color: white;
            font-weight: 600;
        }

        .search-btn {
            background: var(--primary);
            color: white;
            border: none;
            font-weight: 600;
            cursor: pointer;
        }

        .search-btn:hover {
            background: #0062cc;
        }

        /* Results Area */
        .result-panel {
            flex: 1;
            margin-top: 20px;
            overflow-y: auto;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }

        .route-summary {
            background: #fff;
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 16px;
            border: 1px solid #eee;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .metric-value {
            font-weight: 600;
            color: var(--primary);
        }

        .timeline {
            position: relative;
            padding-left: 20px;
            margin-top: 10px;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 7px;
            top: 5px;
            bottom: 5px;
            width: 2px;
            background: #e5e5ea;
        }

        .step {
            position: relative;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .step-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #ccc;
            position: absolute;
            left: -18px;
            top: 2px;
            z-index: 2;
        }

        .step.transfer .step-dot {
            border-color: var(--text-main);
            background: var(--text-main);
        }

        .line-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            color: white;
            font-size: 10px;
            font-weight: bold;
            margin-right: 5px;
        }

        /* Map Area */
        .map-container {
            flex: 1;
            position: relative;
            background: #fff;
            overflow: hidden;
            cursor: grab;
        }

        .map-container:active {
            cursor: grabbing;
        }

        #metroCanvas {
            width: 100%;
            height: 100%;
        }

        .map-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <div class="sidebar">
        <div class="brand">
            <span style="color: #D32F2F;">ğŸš‡</span> å—äº¬åœ°é“é€š
        </div>

        <div class="input-group">
            <label>èµ·ç‚¹ç«™ (Start)</label>
            <select id="startStation"></select>
        </div>

        <div class="input-group">
            <label>ç»ˆç‚¹ç«™ (End)</label>
            <select id="endStation"></select>
        </div>

        <label>è§„åˆ’åå¥½ (Preference)</label>
        <div class="strategy-group">
            <button class="strategy-btn active" onclick="setStrategy('stops')">æœ€å°‘ç«™æ•°</button>
            <button class="strategy-btn" onclick="setStrategy('transfers')">æœ€å°‘æ¢ä¹˜</button>
            <button class="strategy-btn" onclick="setStrategy('time')">æœ€çŸ­æ—¶é—´</button>
        </div>

        <button class="search-btn" onclick="calculateRoute()">æŸ¥è¯¢è·¯çº¿</button>

        <div class="result-panel" id="resultPanel">
            <div style="text-align: center; color: #999; margin-top: 50px;">
                è¯·é€‰æ‹©ç«™ç‚¹å¼€å§‹æŸ¥è¯¢<br>
                <small>æ”¯æŒæ‹–æ‹½å³ä¾§åœ°å›¾æŸ¥çœ‹å…¨è²Œ</small>
            </div>
        </div>
    </div>

    <div class="map-container">
        <div class="map-overlay">
            æ»šè½®ç¼©æ”¾ â€¢ æ‹–æ‹½å¹³ç§» â€¢ èŠ‚ç‚¹è‡ªåŠ¨å¸ƒå±€
        </div>
        <canvas id="metroCanvas"></canvas>
    </div>

    <script>
        // --- 1. æ•°æ®å±‚ (Data Layer) ---
        // æ¨¡æ‹ŸçœŸå®åœ°é“æ•°æ®ç»“æ„ã€‚ä¸ºäº†æ¼”ç¤ºï¼Œé€‰å–äº†æ ¸å¿ƒéª¨å¹²ç½‘ç»œã€‚
        // é¢œè‰²é…ç½®
        const lineColors = {
            "1": "#3498DB", "2": "#E74C3C", "3": "#2ECC71", "4": "#9B59B6",
            "10": "#F1C40F", "S1": "#1ABC9C", "S3": "#E67E22", "S8": "#E67E22"
        };

        // ç«™ç‚¹å®šä¹‰ (Line list)
        // æ³¨æ„ï¼šè¿™é‡Œæ˜¯æ ¹æ®æä¾›çš„å›¾ç‰‡æå–çš„æ ¸å¿ƒæ‹“æ‰‘ç»“æ„
        const metroData = {
            "1": ["è¿ˆçš‹æ¡¥", "çº¢å±±åŠ¨ç‰©å›­", "å—äº¬ç«™", "æ–°æ¨¡èŒƒé©¬è·¯", "ç„æ­¦é—¨", "é¼“æ¥¼", "ç æ±Ÿè·¯", "æ–°è¡—å£", "å¼ åºœå›­", "ä¸‰å±±è¡—", "ä¸­åé—¨", "å®‰å¾·é—¨", "å¤©éš†å¯º", "è½¯ä»¶å¤§é“", "èŠ±ç¥åº™", "å—äº¬å—ç«™", "åŒé¾™å¤§é“", "æ²³å®šæ¡¥", "èƒœå¤ªè·¯", "ç™¾å®¶æ¹–"],
            "2": ["æ²¹åŠæ¡¥", "é›¨æ¶¦å¤§è¡—", "å…ƒé€š", "å¥¥ä½“ä¸œ", "å…´éš†å¤§è¡—", "é›†åº†é—¨å¤§è¡—", "äº‘é”¦è·¯", "è«æ„æ¹–", "æ±‰ä¸­é—¨", "ä¸Šæµ·è·¯", "æ–°è¡—å£", "å¤§è¡Œå®«", "è¥¿å®‰é—¨", "æ˜æ•…å®«", "ç©†æ–¯æ—", "ä¸‹é©¬åŠ", "å­é™µå«", "é’Ÿçµè¡—", "é©¬ç¾¤", "é‡‘é©¬è·¯", "ä»™é¹¤é—¨", "å­¦åˆ™è·¯", "ä»™æ—ä¸­å¿ƒ", "ç¾Šå±±å…¬å›­", "å—å¤§ä»™æ—æ ¡åŒº", "ç»å¤©è·¯"],
            "3": ["æ—åœº", "æ˜Ÿç«è·¯", "ä¸œå¤§æˆè´¤å­¦é™¢", "æ³°å†¯è·¯", "å¤©æ¶¦åŸ", "æŸ³æ´²ä¸œè·¯", "ä¸Šå…ƒé—¨", "äº”å¡˜å¹¿åœº", "å°å¸‚", "å—äº¬ç«™", "æ–°åº„", "é¸¡é¸£å¯º", "æµ®æ¡¥", "å¤§è¡Œå®«", "å¸¸åºœè¡—", "å¤«å­åº™", "æ­¦å®šé—¨", "é›¨èŠ±é—¨", "å¡å­é—¨", "å¤§æ˜è·¯", "æ˜å‘å¹¿åœº", "å—äº¬å—ç«™", "å®è¿å¤§é“", "èƒœå¤ªè¥¿è·¯", "å¤©å…ƒè¥¿è·¯", "ä¹é¾™æ¹–", "è¯šä¿¡å¤§é“", "ä¸œå¤§ä¹é¾™æ¹–æ ¡åŒº", "ç§£å‘¨ä¸œè·¯"],
            "4": ["é¾™æ±Ÿ", "å—è‰ºÂ·äºŒå¸ˆÂ·è‰åœºé—¨", "äº‘å—è·¯", "é¼“æ¥¼", "é¸¡é¸£å¯º", "ä¹åå±±", "å²—å­æ‘", "è’‹ç‹åº™", "ç‹å®¶æ¹¾", "èšå®å±±", "è‹å®æ€»éƒ¨Â·å¾åº„", "é‡‘é©¬è·¯", "æ±‡é€šè·¯", "çµå±±", "ä¸œæµ", "å­ŸåŒ—", "è¥¿å²—æ¡¦å¢…", "ä»™æ—æ¹–"],
            "10": ["å®‰å¾·é—¨", "å°è¡Œ", "ä¸­èƒœ", "å…ƒé€š", "å¥¥ä½“ä¸­å¿ƒ", "æ¢¦éƒ½å¤§è¡—", "ç»¿åšå›­", "æ±Ÿå¿ƒæ´²", "ä¸´æ±Ÿ", "æµ¦å£ä¸‡æ±‡åŸ", "å—äº¬å·¥ä¸šå¤§å­¦", "é¾™åè·¯", "æ–‡å¾·è·¯", "é›¨å±±è·¯"],
            "S1": ["å—äº¬å—ç«™", "ç¿ å±å±±", "æ²³æµ·å¤§å­¦Â·ä½›åŸè¥¿è·¯", "å‰å°å¤§é“", "æ­£æ–¹ä¸­è·¯", "ç¿”å®‡è·¯åŒ—", "ç¿”å®‡è·¯å—", "ç¦„å£æœºåœº"],
            "S8": ["æ³°å†¯è·¯", "æ³°å±±æ–°æ‘", "é«˜æ–°å¼€å‘åŒº", "ä¿¡æ¯å·¥ç¨‹å¤§å­¦", "å¸ç”²ç”¸", "å¤§å‚", "è‘›å¡˜", "é•¿èŠ¦", "åŒ–å·¥å›­", "å…­åˆå¼€å‘åŒº", "é¾™æ± ", "é›„å·", "å‡¤å‡°å±±å…¬å›­", "æ–¹å·å¹¿åœº", "æ²ˆæ¡¥", "å…«ç™¾æ¡¥", "é‡‘ç‰›æ¹–"]
        };

        // ç‰©ç†å‚æ•° (Advanced Requirements)
        const CONSTANTS = {
            AVG_SPEED_KMH: 80, // åœ°é“å¹³å‡é€Ÿåº¦ km/h
            DIST_BETWEEN_STATIONS_KM: 2.5, // å‡è®¾å¹³å‡ç«™é—´è· (ç®€åŒ–æ¨¡å‹)
            TIME_DWELL_SEC: 30, // T2: åœç«™æ—¶é—´
            TIME_TRANSFER_SEC: 300, // T3: æ¢ä¹˜è€—æ—¶ (5åˆ†é’Ÿ)
        };

        // --- 2. ç®—æ³•å±‚ (Algorithm Layer) ---

        // æ„å»ºå›¾ç»“æ„
        class MetroGraph {
            constructor() {
                this.adjList = new Map(); // é‚»æ¥è¡¨: Station -> [{to, line, dist}]
                this.stations = new Set();
                this.stationToLines = new Map(); // Station -> [Line1, Line2...]
            }

            addConnection(u, v, line) {
                if (!this.adjList.has(u)) this.adjList.set(u, []);
                if (!this.adjList.has(v)) this.adjList.set(v, []);

                // é¿å…é‡å¤è¾¹
                const exists = this.adjList.get(u).find(e => e.to === v && e.line === line);
                if (!exists) {
                    this.adjList.get(u).push({ to: v, line: line });
                    this.adjList.get(v).push({ to: u, line: line });
                }

                this.stations.add(u);
                this.stations.add(v);

                if (!this.stationToLines.has(u)) this.stationToLines.set(u, new Set());
                if (!this.stationToLines.has(v)) this.stationToLines.set(v, new Set());
                this.stationToLines.get(u).add(line);
                this.stationToLines.get(v).add(line);
            }

            buildFromData(data) {
                for (const [line, stations] of Object.entries(data)) {
                    for (let i = 0; i < stations.length - 1; i++) {
                        this.addConnection(stations[i], stations[i + 1], line);
                    }
                }
            }
        }

        const graph = new MetroGraph();
        graph.buildFromData(metroData);

        // ä¼˜å…ˆé˜Ÿåˆ—å®ç° (æœ€å°å †)
        class PriorityQueue {
            constructor() { this.values = []; }
            enqueue(val, priority) {
                this.values.push({ val, priority });
                this.sort();
            }
            dequeue() { return this.values.shift(); }
            sort() { this.values.sort((a, b) => a.priority - b.priority); }
            isEmpty() { return this.values.length === 0; }
        }

        // æ ¸å¿ƒç®—æ³•è·¯ç”±
        function findPath(start, end, strategy) {
            if (strategy === 'stops') return bfs(start, end);
            if (strategy === 'transfers') return dijkstraTransfers(start, end);
            if (strategy === 'time') return dijkstraTime(start, end);
        }

        // 1. æœ€å°‘ç«™æ•° (BFS) - å‡è®¾è¾¹æƒé‡ç›¸ç­‰
        function bfs(start, end) {
            let queue = [[start]];
            let visited = new Set([start]);

            while (queue.length > 0) {
                let path = queue.shift();
                let node = path[path.length - 1];

                if (node === end) return formatResult(path, 'stops');

                let neighbors = graph.adjList.get(node) || [];
                for (let neighborObj of neighbors) {
                    if (!visited.has(neighborObj.to)) {
                        visited.add(neighborObj.to);
                        let newPath = [...path, neighborObj.to];
                        queue.push(newPath);
                    }
                }
            }
            return null;
        }

        // 2. æœ€å°‘æ¢ä¹˜ (Dijkstra)
        // æƒé‡è®¾è®¡ï¼šåŒçº¿è·¯ç§»åŠ¨ Cost=1ï¼Œæ¢ä¹˜ Cost=1000ã€‚è¿™æ ·ç®—æ³•ä¼šä¼˜å…ˆé€‰æ‹©æ¢ä¹˜å°‘çš„è·¯å¾„ã€‚
        function dijkstraTransfers(start, end) {
            let pq = new PriorityQueue();
            pq.enqueue({ node: start, path: [start], lines: [], cost: 0, lastLine: null }, 0);
            let visited = new Map(); // node -> minCost

            while (!pq.isEmpty()) {
                let { val } = pq.dequeue();
                let { node, path, lines, cost, lastLine } = val;

                if (visited.has(node) && visited.get(node) < cost) continue;
                visited.set(node, cost);

                if (node === end) return formatResult(path, 'transfers');

                let neighbors = graph.adjList.get(node) || [];
                for (let neighborObj of neighbors) {
                    let newCost = cost;
                    let isTransfer = (lastLine !== null && lastLine !== neighborObj.line);

                    // æƒ©ç½šæœºåˆ¶ï¼šæ¢ä¹˜ +1000ï¼Œ æ¯ä¸€ç«™ +1 (ä½œä¸ºæ¬¡è¦æ’åºæ¡ä»¶ï¼šæ¢ä¹˜ç›¸åŒæ—¶é€‰ç«™å°‘çš„)
                    if (isTransfer) newCost += 1000;
                    newCost += 1;

                    // è®°å½•çº¿è·¯
                    let newLines = [...lines];
                    if (path.length === 1 || isTransfer) newLines.push(neighborObj.line);

                    pq.enqueue({
                        node: neighborObj.to,
                        path: [...path, neighborObj.to],
                        lines: newLines,
                        cost: newCost,
                        lastLine: neighborObj.line
                    }, newCost);
                }
            }
            return null;
        }

        // 3. æœ€çŸ­æ—¶é—´ (Time Dijkstra)
        // T = Dist/V + T_dwell + (If Transfer: T_transfer)
        function dijkstraTime(start, end) {
            let pq = new PriorityQueue();
            pq.enqueue({ node: start, path: [start], time: 0, lastLine: null }, 0);
            let visited = new Map();

            while (!pq.isEmpty()) {
                let { val } = pq.dequeue();
                let { node, path, time, lastLine } = val;

                if (visited.has(node) && visited.get(node) < time) continue;
                visited.set(node, time);

                if (node === end) return formatResult(path, 'time', time);

                let neighbors = graph.adjList.get(node) || [];
                for (let neighborObj of neighbors) {
                    let addedTime = 0;

                    // è¡Œé©¶æ—¶é—´ (å‡è®¾æ¯ç«™é—´è·å›ºå®š)
                    let travelTime = (CONSTANTS.DIST_BETWEEN_STATIONS_KM / CONSTANTS.AVG_SPEED_KMH) * 3600; // ç§’
                    addedTime += travelTime;

                    // åœç«™æ—¶é—´ (T2)
                    if (path.length > 1) addedTime += CONSTANTS.TIME_DWELL_SEC;

                    // æ¢ä¹˜æ—¶é—´ (T3)
                    if (lastLine !== null && lastLine !== neighborObj.line) {
                        addedTime += CONSTANTS.TIME_TRANSFER_SEC;
                    }

                    let newTime = time + addedTime;

                    pq.enqueue({
                        node: neighborObj.to,
                        path: [...path, neighborObj.to],
                        time: newTime,
                        lastLine: neighborObj.line
                    }, newTime);
                }
            }
        }

        // ç»“æœæ ¼å¼åŒ–
        function formatResult(path, type, calculatedTime = 0) {
            // é‡å»ºè¯¦ç»†è·¯å¾„ä¿¡æ¯ (åŒ…å«çº¿è·¯)
            let detailedPath = [];
            let transfers = 0;
            let stops = path.length - 1;
            let currentLine = null;

            for (let i = 0; i < path.length - 1; i++) {
                let u = path[i];
                let v = path[i + 1];
                // æ‰¾åˆ°è¿æ¥ u å’Œ v çš„çº¿è·¯
                let edge = graph.adjList.get(u).find(e => e.to === v);

                // æ£€æµ‹æ¢ä¹˜
                // æ³¨æ„ï¼šå¦‚æœä¸¤ç«™ä¹‹é—´æœ‰å¤šæ¡çº¿è·¯(å…±çº¿)ï¼Œè¿™ç®€å•çš„é€»è¾‘å¯èƒ½ä¼šé€‰é”™ï¼Œä½†åœ¨å—äº¬åœ°é“æ ¸å¿ƒæ®µå…±çº¿è¾ƒå°‘ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†ã€‚
                // ä¸¥è°¨åšæ³•æ˜¯åœ¨Dijkstraä¸­è®°å½•é€‰æ‹©çš„Edgeã€‚

                // ä¸ºäº†åœ¨BFSä¸­ä¹Ÿèƒ½å‡†ç¡®æ˜¾ç¤ºçº¿è·¯ï¼Œæˆ‘ä»¬éœ€è¦åœ¨éå†æ—¶æ¨æ–­
                // è¿™é‡Œç®€å•å–ç¬¬ä¸€æ¡åŒ¹é…çš„çº¿è·¯ã€‚
                // å¯¹äº "æœ€å°‘æ¢ä¹˜" ç®—æ³•ï¼Œè¿™åªæ˜¯å±•ç¤ºï¼Œå®é™…è®¡ç®—åœ¨ç®—æ³•å†…éƒ¨å®Œæˆäº†ã€‚

                // å¦‚æœå·²ç»åœ¨æŸæ¡çº¿ä¸Šï¼Œä¸”ä¸‹ä¸€ç«™ä¹Ÿåœ¨è¯¥çº¿ä¸Šï¼Œä¿æŒã€‚å¦åˆ™åˆ‡æ¢ã€‚
                let lineToUse = edge.line;
                // å°è¯•ä¿æŒå½“å‰çº¿è·¯ä»¥å‡å°‘æ˜¾ç¤ºçš„â€œå‡æ¢ä¹˜â€
                let possibleLines = graph.adjList.get(u).filter(e => e.to === v).map(e => e.line);
                if (currentLine && possibleLines.includes(currentLine)) {
                    lineToUse = currentLine;
                }

                if (currentLine !== null && currentLine !== lineToUse) {
                    transfers++;
                    detailedPath.push({ type: 'transfer', station: u, from: currentLine, to: lineToUse });
                }
                currentLine = lineToUse;

                if (i === 0) detailedPath.push({ type: 'start', station: u, line: currentLine });
                detailedPath.push({ type: 'move', to: v, line: currentLine });
            }

            // ä¼°ç®—æ—¶é—´ (å¦‚æœæ˜¯BFSæˆ–Transfersæ¨¡å¼ï¼Œéœ€è¦åè®¡ç®—)
            let totalTime = calculatedTime;
            if (type !== 'time') {
                // ç®€å•ä¼°ç®—: (Stops * 2.5km / 80kmh) + (Stops * 30s) + (Transfers * 5min)
                let travelT = (stops * CONSTANTS.DIST_BETWEEN_STATIONS_KM / CONSTANTS.AVG_SPEED_KMH) * 60; // min
                let stopT = (stops * CONSTANTS.TIME_DWELL_SEC) / 60;
                let transT = (transfers * CONSTANTS.TIME_TRANSFER_SEC) / 60;
                totalTime = (travelT + stopT + transT) * 60; // seconds
            }

            return {
                path: path,
                detailedSteps: detailedPath,
                stops: stops,
                transfers: transfers,
                timeSec: Math.round(totalTime)
            };
        }

        // --- 3. è§†å›¾å±‚ (View Layer) ---

        let currentStrategy = 'stops';

        // åˆå§‹åŒ–ä¸‹æ‹‰æ¡†
        const stations = Array.from(graph.stations).sort((a, b) => a.localeCompare(b, 'zh'));
        const startSelect = document.getElementById('startStation');
        const endSelect = document.getElementById('endStation');

        stations.forEach(s => {
            startSelect.add(new Option(s, s));
            endSelect.add(new Option(s, s));
        });
        // é»˜è®¤å€¼
        startSelect.value = "å—äº¬ç«™";
        endSelect.value = "å—äº¬å—ç«™";

        function setStrategy(s) {
            currentStrategy = s;
            document.querySelectorAll('.strategy-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`button[onclick="setStrategy('${s}')"]`).classList.add('active');
        }

        function formatTime(seconds) {
            let m = Math.floor(seconds / 60);
            return `${m} åˆ†é’Ÿ`;
        }

        function calculateRoute() {
            const start = startSelect.value;
            const end = endSelect.value;

            if (start === end) {
                alert("èµ·ç‚¹å’Œç»ˆç‚¹ä¸èƒ½ç›¸åŒ");
                return;
            }

            const result = findPath(start, end, currentStrategy);
            renderResult(result);
            highlightPathOnMap(result ? result.path : []);
        }

        function renderResult(res) {
            const panel = document.getElementById('resultPanel');
            if (!res) {
                panel.innerHTML = "<div style='text-align:center; padding:20px'>æœªæ‰¾åˆ°è·¯çº¿</div>";
                return;
            }

            let html = `
            <div class="route-summary">
                <div class="metric"><span>é¢„è®¡è€—æ—¶</span> <span class="metric-value">${formatTime(res.timeSec)}</span></div>
                <div class="metric"><span>é€”å¾„ç«™ç‚¹</span> <span class="metric-value">${res.stops} ç«™</span></div>
                <div class="metric"><span>æ¢ä¹˜æ¬¡æ•°</span> <span class="metric-value">${res.transfers} æ¬¡</span></div>
            </div>
            <div class="timeline">
        `;

            res.detailedSteps.forEach((step, index) => {
                const color = lineColors[step.line] || '#999';

                if (step.type === 'start') {
                    html += `
                    <div class="step">
                        <div class="step-dot" style="border-color: ${color}"></div>
                        <strong>${step.station}</strong> <br>
                        <span class="line-badge" style="background:${color}">${step.line}å·çº¿</span>
                    </div>
                `;
                } else if (step.type === 'transfer') {
                    const toColor = lineColors[step.to] || '#999';
                    html += `
                    <div class="step transfer">
                        <div class="step-dot"></div>
                        <div style="color:var(--text-main); font-weight:bold;">ç«™å†…æ¢ä¹˜</div>
                        <small style="color:#666">æ­¥è¡Œçº¦ 5 åˆ†é’Ÿ</small><br>
                        <span class="line-badge" style="background:${toColor}">æ¢ä¹˜ ${step.to}å·çº¿</span>
                    </div>
                `;
                } else if (step.type === 'move') {
                    // åªæ˜¾ç¤ºå…³é”®èŠ‚ç‚¹ï¼ˆç»ˆç‚¹æˆ–æ¢ä¹˜å‰ä¸€ç«™ï¼‰ï¼Œé¿å…åˆ—è¡¨è¿‡é•¿ï¼Ÿ
                    // ä¸ºäº†æ¼”ç¤ºè¯¦ç»†ä¿¡æ¯ï¼Œè¿™é‡Œæ˜¾ç¤ºæ‰€æœ‰ï¼Œä½†æŠŠä¸­é—´ç«™ç¨å¾®å¼±åŒ–
                    const isLast = index === res.detailedSteps.length - 1;
                    if (isLast) {
                        html += `
                        <div class="step">
                            <div class="step-dot" style="background:${color}; border-color:${color}"></div>
                            <strong>${step.to}</strong> (ç»ˆç‚¹)
                        </div>
                    `;
                    } else {
                        // ä¸­é—´ç«™ç‚¹å¯ä»¥ç®€åŒ–ï¼Œè¿™é‡Œæš‚ä¸”å…¨éƒ¨åˆ—å‡º
                        html += `
                        <div class="step" style="opacity:0.6; font-size:12px; margin-bottom:8px;">
                            <div class="step-dot" style="width:8px; height:8px; left:-16px; border-color:${color}"></div>
                            ${step.to}
                        </div>
                    `;
                    }
                }
            });

            html += `</div>`;
            panel.innerHTML = html;
        }

        // --- 4. å¯è§†åŒ–å±‚ (Canvas Force Graph) ---
        // ==========================================
        // === ä»¥ä¸‹æ˜¯ é‡ç‚¹ä¿®æ”¹çš„ å¯è§†åŒ–/ç‰©ç†å¼•æ“ éƒ¨åˆ† ===
        // ==========================================

      const canvas = document.getElementById('metroCanvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    
    let nodes = [];
    let links = [];
    
    // ç‰©ç†æ¨¡æ‹Ÿå‚æ•°
    let simulationAlpha = 1.0; 
    
    // 1. é«˜æ¸…å±é€‚é… (High DPI)
    function setupCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.parentElement.getBoundingClientRect();
        // åªæœ‰å½“å®¹å™¨æœ‰å°ºå¯¸æ—¶æ‰è®¾ç½®ï¼Œé¿å…åˆå§‹åŒ–é”™è¯¯
        if (rect.width === 0 || rect.height === 0) return false;

        width = rect.width;
        height = rect.height;
        
        // è®¾ç½® Canvas å®é™…åƒç´ å¤§å°
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        // è®¾ç½® CSS æ˜¾ç¤ºå¤§å°
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        
        // å­˜å‚¨ DPR ä¾›ç»˜åˆ¶ä½¿ç”¨
        ctx.dpr = dpr;
        return true;
    }

    function initVisData() {
        if (!setupCanvas()) return;
        
        // ä¿æŒåŸæœ‰çš„é”šç‚¹é€»è¾‘ï¼Œè¿™å¯¹äºç»´æŒå½¢çŠ¶å¾ˆé‡è¦
        const geoAnchors = {
            'æ–°è¡—å£': {x: 0.5, y: 0.45}, 
            'å—äº¬ç«™': {x: 0.5, y: 0.25},
            'å—äº¬å—ç«™': {x: 0.5, y: 0.65},
            'è¿ˆçš‹æ¡¥': {x: 0.55, y: 0.15},
            'æ²¹åŠæ¡¥': {x: 0.35, y: 0.6},
            'ç»å¤©è·¯': {x: 0.85, y: 0.35},
            'æ—åœº': {x: 0.3, y: 0.1},
            'ç§£å‘¨ä¸œè·¯': {x: 0.5, y: 0.8},
            'é›¨å±±è·¯': {x: 0.2, y: 0.65},
            'å®‰å¾·é—¨': {x: 0.48, y: 0.6},
            'ç¦„å£æœºåœº': {x: 0.55, y: 0.95},
            'é‡‘ç‰›æ¹–': {x: 0.6, y: 0.05},
            'æ³°å†¯è·¯': {x: 0.35, y: 0.15},
            'é¾™æ±Ÿ': {x: 0.35, y: 0.35},
            'ä»™æ—æ¹–': {x: 0.9, y: 0.3},
            'é«˜å®¶å†²': {x: 0.1, y: 0.9}
        };

        nodes = Array.from(graph.stations).map(id => {
            const anchor = geoAnchors[id];
            const initialX = anchor ? anchor.x * width : width/2 + (Math.random() - 0.5) * 200;
            const initialY = anchor ? anchor.y * height : height/2 + (Math.random() - 0.5) * 200;
            
            return {
                id, 
                x: initialX, 
                y: initialY,
                vx: 0, vy: 0,
                fx: anchor ? anchor.x * width : null,
                fy: anchor ? anchor.y * height : null,
                isAnchor: !!anchor,
                // é¢„è®¡ç®—çº¿è·¯é¢œè‰²ï¼Œå¦‚æœæ˜¯æ¢ä¹˜ç«™åˆ™ç”¨ç‰¹æ®Šè‰²
                lines: Array.from(graph.stationToLines.get(id) || [])
            };
        });

        links = [];
        graph.adjList.forEach((neighbors, id) => {
            neighbors.forEach(n => {
                if (id < n.to) {
                    links.push({ source: id, target: n.to, line: n.line });
                }
            });
        });
        
        simulationAlpha = 1.0;
    }

    function simulationStep() {
        if (simulationAlpha < 0.005) return;
        simulationAlpha *= 0.96; // ç¨å¾®åŠ å¿«æ”¶æ•›

        // 1. æ–¥åŠ›
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                let dx = nodes[i].x - nodes[j].x;
                let dy = nodes[i].y - nodes[j].y;
                let distSq = dx*dx + dy*dy;
                if (distSq === 0) distSq = 1;
                if (distSq > 60000) continue; 

                let dist = Math.sqrt(distSq);
                // å¢åŠ æ–¥åŠ›ä»¥æ’‘å¼€ç½‘ç»œ
                let force = (1000 * simulationAlpha) / distSq; 
                
                let fx = (dx/dist) * force;
                let fy = (dy/dist) * force;
                
                if (nodes[i].fx === null) { nodes[i].vx += fx; nodes[i].vy += fy; }
                if (nodes[j].fx === null) { nodes[j].vx -= fx; nodes[j].vy -= fy; }
            }
        }

        // 2. å¼¹ç°§åŠ›
        links.forEach(link => {
            let s = nodes.find(n => n.id === link.source);
            let t = nodes.find(n => n.id === link.target);
            if (!s || !t) return;

            let dx = t.x - s.x;
            let dy = t.y - s.y;
            let dist = Math.sqrt(dx*dx + dy*dy) || 1;
            
            // ç¨å¾®ç¼©çŸ­ç›®æ ‡è·ç¦»ï¼Œè®©çº¿æ¡æ›´ç´§å‡‘
            let targetDist = 25; 
            
            let force = (dist - targetDist) * 0.15 * simulationAlpha; // å¢åŠ ç¡¬åº¦
            let fx = (dx/dist) * force;
            let fy = (dy/dist) * force;

            if (s.fx === null) { s.vx += fx; s.vy += fy; }
            if (t.fx === null) { t.vx -= fx; t.vy -= fy; }
        });

        // 3. æ›´æ–°ä½ç½®
        nodes.forEach(n => {
            if (n.fx !== null) {
                n.x = n.fx; n.y = n.fy; n.vx = 0; n.vy = 0;
                return;
            }
            // å¼±å‘å¿ƒåŠ›
            n.vx += (width/2 - n.x) * 0.008 * simulationAlpha;
            n.vy += (height/2 - n.y) * 0.008 * simulationAlpha;

            n.vx *= 0.6; 
            n.vy *= 0.6;
            n.x += n.vx;
            n.y += n.vy;
        });
    }

    let transform = { k: 1, x: 0, y: 0 };
    let activePathSet = new Set();

    function draw() {
        const dpr = ctx.dpr || 1;
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // å…³é”®ï¼šåº”ç”¨ DPR ç¼©æ”¾å’Œç”¨æˆ·å˜æ¢
        ctx.translate(transform.x * dpr, transform.y * dpr);
        ctx.scale(transform.k * dpr, transform.k * dpr);

        // æ ·å¼é…ç½®
        const baseLineWidth = 3;
        const highlightWidth = 6;
        
        // 1. ç»˜åˆ¶è¿çº¿ (åˆ†ä¸¤å±‚ç»˜åˆ¶ï¼šåº•å±‚ç™½è‰²æè¾¹ï¼Œé¡¶å±‚é¢œè‰²)
        // è¿™æ ·å¯ä»¥åˆ¶é€ å‡º"çº¿è·¯äº¤å‰æ—¶çš„ç•™ç™½æ•ˆæœ"ï¼Œå‡å°‘è§†è§‰æ··ä¹±
        
        // Layer 1: White Outline (Global)
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        links.forEach(l => {
            let s = nodes.find(n => n.id === l.source);
            let t = nodes.find(n => n.id === l.target);
            if (!s || !t) return;

            ctx.beginPath();
            ctx.moveTo(s.x, s.y);
            ctx.lineTo(t.x, t.y);
            
            // æè¾¹å®½åº¦ = çº¿å®½ + é—´éš™
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = baseLineWidth + 3; 
            ctx.globalAlpha = 1.0;
            ctx.stroke();
        });

        // Layer 2: Colored Lines
        links.forEach(l => {
            let s = nodes.find(n => n.id === l.source);
            let t = nodes.find(n => n.id === l.target);
            if (!s || !t) return;

            ctx.beginPath();
            ctx.moveTo(s.x, s.y);
            ctx.lineTo(t.x, t.y);
            
            let color = lineColors[l.line] || '#ccc';
            let isActive = activePathSet.size > 0;
            let isHighlight = isActive && activePathSet.has(l.source) && activePathSet.has(l.target);
            
            ctx.strokeStyle = color;
            ctx.lineWidth = isHighlight ? highlightWidth : baseLineWidth;
            ctx.globalAlpha = isActive ? (isHighlight ? 1.0 : 0.1) : 0.8;
            
            ctx.stroke();
        });

        // 2. ç»˜åˆ¶ç«™ç‚¹
        nodes.forEach(n => {
            let isActive = activePathSet.size > 0;
            let isHighlight = activePathSet.has(n.id);
            
            // å¿½ç•¥éé«˜äº®èŠ‚ç‚¹ï¼ˆåœ¨æ¿€æ´»æ¨¡å¼ä¸‹ï¼‰
            if (isActive && !isHighlight) return;

            ctx.beginPath();
            // æ¢ä¹˜ç«™ç”»å¤§ä¸€ç‚¹
            let isTransfer = n.lines.length > 1;
            let radius = isHighlight ? 6 : (isTransfer ? 4 : 3);
            
            ctx.arc(n.x, n.y, radius, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            
            // è¾¹æ¡†é¢œè‰²ï¼šå¦‚æœæ˜¯æ¢ä¹˜ç«™ï¼Œç”¨é»‘è‰²æˆ–æ·±ç°ï¼Œå¦åˆ™ç”¨çº¿è·¯è‰²
            // ç®€å•èµ·è§ï¼Œæ¢ä¹˜ç«™ç”¨é»‘è‰²ï¼Œæ™®é€šç«™ç”¨çº¿è·¯è‰²
            let strokeColor = '#666';
            if (!isTransfer && n.lines.length > 0) {
                strokeColor = lineColors[Array.from(n.lines)[0]];
            }
            if (isHighlight) strokeColor = '#000';

            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = isHighlight ? 3 : 2;
            ctx.fill();
            ctx.stroke();

            // 3. ç»˜åˆ¶æ–‡å­— (å¸¦ç™½è‰²å…‰æ™•ï¼Œé˜²æ­¢ä¸çº¿è·¯é‡å çœ‹ä¸æ¸…)
            // åªæœ‰ é”šç‚¹ã€é«˜äº®ã€æ¢ä¹˜ç«™ æˆ– æ”¾å¤§æ—¶ æ˜¾ç¤º
            if (n.isAnchor || isHighlight || isTransfer || transform.k > 1.2) {
                ctx.font = isHighlight ? 'bold 12px -apple-system, BlinkMacSystemFont, sans-serif' : '10px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                
                const labelX = n.x + radius + 4;
                const labelY = n.y;

                // å…‰æ™• (Halo)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 3;
                ctx.strokeText(n.id, labelX, labelY);
                
                // æ–‡å­—
                ctx.fillStyle = isHighlight ? '#000' : '#333';
                ctx.fillText(n.id, labelX, labelY);
            }
        });

        ctx.restore();
        
        simulationStep();
        requestAnimationFrame(draw);
    }

    // äº¤äº’é€»è¾‘
    let highlightPathArr = [];
    function highlightPathOnMap(path) {
        highlightPathArr = path;
        activePathSet = new Set(path);
    }

    // äº¤äº’ä¼˜åŒ–
    let draggingNode = null;
    let isDragging = false;
    let lastX, lastY;

    canvas.addEventListener('mousedown', e => {
        const rect = canvas.getBoundingClientRect();
        const dpr = ctx.dpr || 1;
        // è®¡ç®—é¼ æ ‡åœ¨Canvaså†…çš„çœŸå®åæ ‡ï¼ˆè€ƒè™‘ç¼©æ”¾å’Œå¹³ç§»ï¼‰
        const mouseX = (e.clientX - rect.left - transform.x) / transform.k;
        const mouseY = (e.clientY - rect.top - transform.y) / transform.k;
        
        // æŸ¥æ‰¾æœ€è¿‘çš„èŠ‚ç‚¹
        let minDist = 20 / transform.k; 
        let found = null;
        
        nodes.forEach(n => {
            let dx = mouseX - n.x;
            let dy = mouseY - n.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < minDist) {
                minDist = dist;
                found = n;
            }
        });

        if (found) {
            draggingNode = found;
            simulationAlpha = 0.5; 
            draggingNode.fx = draggingNode.x;
            draggingNode.fy = draggingNode.y;
        } else {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        }
    });

    canvas.addEventListener('mousemove', e => {
        if (draggingNode) {
            const rect = canvas.getBoundingClientRect();
            draggingNode.fx = (e.clientX - rect.left - transform.x) / transform.k;
            draggingNode.fy = (e.clientY - rect.top - transform.y) / transform.k;
            simulationAlpha = 0.3; 
        } else if (isDragging) {
            let dx = e.clientX - lastX;
            let dy = e.clientY - lastY;
            transform.x += dx;
            transform.y += dy;
            lastX = e.clientX;
            lastY = e.clientY;
        }
    });

    window.addEventListener('mouseup', () => {
        if (draggingNode) {
            if (!draggingNode.isAnchor) {
                draggingNode.fx = null;
                draggingNode.fy = null;
            }
            draggingNode = null;
        }
        isDragging = false;
    });

    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        let zoomIntensity = 0.1;
        let wheel = e.deltaY < 0 ? 1 : -1;
        let zoom = Math.exp(wheel * zoomIntensity);
        transform.k *= zoom;
    });

    function resize() {
        initVisData(); 
    }

    window.addEventListener('resize', resize);

    // å¯åŠ¨
    setTimeout(() => {
        resize();
        draw();
    }, 50);

    </script>
</body>

</html>